## 简单实现智能指针
#### 引言
在C/C++的编程中，内存管理是一个盛产BUG的重灾区，主要体现在：
* `new` 和 `delete` 需要成对出现，依赖于人要记得做的事情，人总是可能忘记去做，或者后续的模块维护者会忘记这一点。
* 当发生异常的时候，可能无法执行到释放内存的代码。

本文实现了一个简单的智能指针类，智能指针比较常用的有`shared_ptr`,`unique_ptr`,`scope_ptr`,这里打算实现一个简单的`shared_ptr`。

本文会从头到尾，由浅至深的分析实现一个简单的`shared_ptr`类，并且会在最后，简单的剖析`std::shared_ptr`的主要实现，以加深对智能指针的深入理解。

本文实现的智能指针的特点：
* 管理的类需要继承自RefBase的基类，通过这个基类的m_count引用计数，管理的对象的生命期。
* 线程非安全，未来可进一步改进为线程安全。

#### 基本思路
* 对象在离开作用域的时候会自动销毁，此时会调用析构函数。
* 智能指针比较常用的有shared_ptr,unique_ptr,scope_ptr,这里打算实现一个简单的shared_ptr，所以要引入`引用计数`技术。
* 智能指针是一个对象，但这个对象的行为是`pointer-like`的，所以需要重载运算符，最重要的比如：`* 解引用`,`-> 指针行为`。
---
### 实现流程
1） 智能指针是一个模板类，内部管理着一个真实的指针。

---
2） 分析一下指针的创建行为，因为智能指针的行为需要和指针一样，分析这一创建的行为，有助于编写智能指针的`构造函数`：
```cpp
1) char *p1;                        //创建一个野指针，不建议这么做
2) char *p2 = nullptr;              //创建一个空指针
3) const char *p3 = "Hello Wolrd";  //创建一个字符串指针
4) SomeClass *p4 = new SomeClass(); //创建一个指向具体类的指针
5) SomeClass *p5 = p4;              //创建同类型指针
```
尤其需要注意的是：p3指针指向的是`常量区`的字符串，这是`delete`所无法释放的，如果强行`delete p3`，会出现`segmentation fault`。

---
3）需要特别注意`拷贝构造`和`赋值操作`的编写，因为在`shared_ptr`中，这两个操作会使得`引用计数`发生变化。
```cpp
{  
  SmartPointer<SomeClass> spclass1 = new SomeClass; //1
  SmartPointer<SomeClass> spclass2 = new SomeClass; //2
  spclass2 = spclass1;      //3 调用 赋值操作符
}
```
如果不做一些特殊的处理，这里2处new出来的对象将永远不会被释放，而1处new出来的对象，由于有spclass1和spclass2共同管理着，故会被释放两次，是会发生未定义行为的。
所以，在赋值操作的时候，最后需要将原来的对象释放，如果原来的对象被其他的智能指针管理着，一旦释放，其他的智能指针就会变成`野指针`，会发生未定义的行为，而且这里还是会有释放多次的问题，下文利用`引用计数`进行解决。

---
4）引出`引用计数`技术：
刚刚在3）中提到了在`赋值操作`之后，有的指针可能永远不会被释放，有的指针又会变成野指针，被释放多次，这可以采用引用计数的手段来解决。
所谓引用计数：指的是每一个对象负责维护所有引用的计数值。当一个新的引用指向对象时，引用计数就+1，当去掉一个引用时，就-1，当引用计数值等于0的时候，就去销毁对象占用的资源。

---
5）实现引用计数：
最主要的一个问题是『由谁来负责存储这个引用计数值』，假设让智能指针来存储，有可能存在某个指针指针已经被销毁了，而其所指向的资源还有效的情况。
因此这个引用计数需要存储在被引用的资源对象里。一个资源对象对应一个引用计数，当其引用计数为0时，资源对象可以被销毁。

既然打算让资源对象来管理引用计数，那么就需要抽象出一个 基类RefBase，这个基类内部有一个m_count，也向外提供了incRefCount(),decRefCount()这样的接口。任何期望被智能指针所管理的资源类，只要继承RefBase就可以了。

---
6）编写`拷贝构造`和`赋值操作`：
拷贝构造的时候，因为构造的对象是新生成的，所以只需要将传入的对象的m_count++即可。
赋值操作相对麻烦一些：赋值操作往往需要考虑一种特殊情况，即`自我赋值`，往往会在函数开头就去判断是否是自我赋值，但这里实现的时候先将"="右边的对象的m_count++，"="左边的对象的m_count--，看是否等于0，如果是就delete；在这种逻辑下，自我赋值就相当于m_count++后又m_count--，所以还是正确的。需要注意的是，不能马上通过m_pointer = other.m_pointer 将this->m_pointer给覆盖了。
```cpp
SmartPointer& operator = (const SmartPointer& other)
{
    T* tmp = other.m_pointer;
    if(tmp) tmp->incRefCount();
    if(m_pointer && m_pointer->decRefCount() == 0) 
        delete m_pointer;
    m_pointer = tmp;
    return *this;
}
```

---
7) 使SmartPointer类变得pointer-like：
需要重载 `*` 和 `->` ，这个很容易实现
```cpp
T& operator* () const { return *m_pointer; }

T* operator-> () const { return m_pointer; }
```

---
8）比较和判空
在使用指针的过程中，有时候需要对指针的有效性进行判断，有时候又需要比较两个指针是否指向同一块内存空间。
* 针对第一个问题：可以使用`重载转型至bool()`的运算符
```cpp
operator bool() const {
    return mPointer != NULL;
}
```
注意以上和 `重载()`的区别。

但是如果这样做了，
```cpp
if (sp1 == sp3)
```
sp1和sp3首先会转化成bool类型，然后比较，那么就无法通过重载==来实现 比较两个指针是否指向同一块内存空间这样的一个功能了。

因此，决定重载 == 和 != 来满足以上要求

---

9）测试：可以通过`g++ test.cpp -o test -std=c++11`来进行测试。

---
## 智能指针杂谈
下面记录一些随时随地看到想到的关于智能指针的看法和想法，仅供参考，随时可能会更新认知。

私以为：原始指针之所以会导致内存泄露，其主要的原因是`所有权不明确`导致的，一块动态内存被创建出来没有一个明确的`主人`，看上去编程者才是这个指针的master了，所以，其生存期完全由程序员自己控制。

当把指针封装到一个对象里的时候，其实就是在把这个指针指向的内存交给该对象进行管理，这使得内存有了一个明确的主人，当然内存泄露问题也可得以解决。


### 分析std::auto_ptr
分析这个已经被淘汰的智能指针有何用？

首先，它至少初步完成了对指针的封装，使其`pointer-like`，在一定情景下可以使用，但是有一定的局限性，为什么呢？分析一下原因：

实现智能指针需要考虑一个问题：`所有权`，即是完全拷贝一份还是完全转移或者共享一份拷贝。
`std::auto_ptr`的语义是 `完全转移`。
也就是说，以下代码是会导致程序崩溃的。
```cpp
auto_ptr<string> pString(new string("hello")); //创建一个auto_ptr
cout << *pString << endl;                      // ok
auto_ptr<string> pString2(pString);            //拷贝构造出pString2
cout << *pString << endl;                      // wrong, pString = nullptr !
```
由于auto_ptr的完全转移的语义和内部实现，应该类似于move，会导致pString 会在拷贝构造后不再指向原来的内存。

也正是由于这个原因，不能用于STL容器，STL容器是`值语义`的，需要元素支持拷贝。

### 分析std::scope_ptr
scope_ptr可以认为是 auto_ptr 的非copy版本，它把`拷贝构造`和`赋值运算符`都设置成了`private`，这样至少把错误提前到了`编译期`。
所以scope_ptr也不能放入STL容器。

---
### 分析std::shared_ptr
这个是分析的重点，








