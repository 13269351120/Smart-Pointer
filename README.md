## Smart-Pointer
#### 引言
在C/C++的编程中，内存管理是一个盛产BUG的重灾区，主要体现在：
* `new` 和 `delete` 需要成对出现，依赖于人要记得做的事情，人总是可能忘记去做，或者后续的模块维护者会忘记这一点。
* 当发生异常的时候，可能无法执行到释放内存的代码。

本文实现了一个简单的智能指针类，智能指针比较常用的有`shared_ptr`,`unique_ptr`,`scope_ptr`,这里打算实现一个简单的`shared_ptr`。

本文会从头到尾，由浅至深的分析实现一个简单的`shared_ptr`类，并且会在最后，简单的剖析`std::shared_ptr`的主要实现，以加深对智能指针的深入理解。

本文实现的智能指针的特点：
* 管理的类需要继承自RefBase的基类，通过这个基类的m_count引用计数，管理的对象的生命期。
* 线程非安全，未来可进一步改进为线程安全。

#### 基本思路
* 对象在离开作用域的时候会自动销毁，此时会调用析构函数。
* 智能指针比较常用的有shared_ptr,unique_ptr,scope_ptr,这里打算实现一个简单的shared_ptr，所以要引入`引用计数`技术。
* 智能指针是一个对象，但这个对象的行为是`pointer-like`的，所以需要重载运算符，最重要的比如：`* 解引用`,`-> 指针行为`。

### 实现流程
1） 智能指针是一个模板类，内部管理着一个真实的指针。

2） 分析一下指针的创建行为，因为智能指针的行为需要和指针一样，分析这一创建的行为，有助于编写智能指针的`构造函数`：
```cpp
1) char *p1;                        //创建一个野指针，不建议这么做
2) char *p2 = nullptr;              //创建一个空指针
3) const char *p3 = "Hello Wolrd";  //创建一个字符串指针
4) SomeClass *p4 = new SomeClass(); //创建一个指向具体类的指针
5) SomeClass *p5 = p4;              //创建同类型指针
```
尤其需要注意的是：p3指针指向的是`常量区`的字符串，这是`delete`所无法释放的，如果强行`delete p3`，会出现`segmentation fault`。

3）需要特别注意`拷贝构造`和`赋值操作`的编写，因为在`shared_ptr`中，这两个操作会使得`引用计数`发生变化。
```cpp
{  
  SmartPointer<SomeClass> spclass1 = new SomeClass; //1
  SmartPointer<SomeClass> spclass2 = new SomeClass; //2
  spclass2 = spclass1;      //3 调用 赋值操作符
}
```
如果不做一些特殊的处理，这里2处new出来的对象将永远不会被释放，而1处new出来的对象，由于有spclass1和spclass2共同管理着，故会被释放两次，是会发生未定义行为的。
所以，在赋值操作的时候，最后需要将原来的对象释放，如果原来的对象被其他的智能指针管理着，一旦释放，其他的智能指针就会变成`野指针`，会发生未定义的行为，而且这里还是会有释放多次的问题，下文利用`引用计数`进行解决。

4）引出`引用计数`技术：
刚刚在3）中提到了在`赋值操作`之后，有的指针可能永远不会被释放，有的指针又会变成野指针，被释放多次，这可以采用引用计数的手段来解决。
所谓引用计数：指的是每一个对象负责维护所有引用的计数值。当一个新的引用指向对象时，引用计数就+1，当去掉一个引用时，就-1，当引用计数值等于0的时候，就去销毁对象占用的资源。

5）实现引用计数：
最主要的一个问题是『由谁来负责存储这个引用计数值』，假设让智能指针来存储，有可能存在某个指针指针已经被销毁了，而其所指向的资源还有效的情况。
因此这个引用计数需要存储在被引用的资源对象里。一个资源对象对应一个引用计数，当其引用计数为0时，资源对象可以被销毁。

既然打算让资源对象来管理引用计数，那么就需要抽象出一个 基类RefBase，这个基类内部有一个m_count，也向外提供了incRefCount(),decRefCount()这样的接口。任何期望被智能指针所管理的资源类，只要继承RefBase就可以了。

6）编写`拷贝构造`和`赋值操作`：
拷贝构造的时候，因为构造的对象是新生成的，所以只需要将传入的对象的m_count++即可。
赋值操作相对麻烦一些：赋值操作往往需要考虑一种特殊情况，即`自我赋值`，往往会在函数开头就去判断是否是自我赋值，但这里实现的时候先将"="右边的对象的m_count++，"="左边的对象的m_count--，看是否等于0，如果是就delete；在这种逻辑下，自我赋值就相当于m_count++后又m_count--，所以还是正确的。需要注意的是，不能马上通过m_pointer = other.m_pointer 将this->m_pointer给覆盖了。
```cpp
SmartPointer& operator = (const SmartPointer& other)
{
    T* tmp = other.m_pointer;
    if(tmp) tmp->incRefCount();
    if(m_pointer && m_pointer->decRefCount() == 0) 
        delete m_pointer;
    m_pointer = tmp;
    return *this;
}
```

7) 使SmartPointer类变得pointer-like：
需要重载 `*` 和 `->` ，这个很容易实现
```cpp
T& operator* () const { return *m_pointer; }

T* operator-> () const { return m_pointer; }
```

8）比较和判空
在使用指针的过程中，有时候需要对指针的有效性进行判断，有时候又需要比较两个指针是否指向同一块内存空间。
* 针对第一个问题：可以使用`重载转型至bool()`的运算符
```cpp
operator bool() const {
    return mPointer != NULL;
}
```
注意以上和 `重载()`的区别。

但是如果这样做了，
```cpp
if (sp1 == sp3)
```
sp1和sp3首先会转化成bool类型，然后比较，那么就无法通过重载==来实现 比较两个指针是否指向同一块内存空间这样的一个功能了。

因此，决定重载 == 和 != 来满足以上要求


9）测试：可以通过`g++ test.cpp -o test -std=c++11`来进行测试。

### 分析std::shared_ptr









